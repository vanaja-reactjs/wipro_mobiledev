Assessment 1:  SDLC Overview - Create a one-page infographic that outlines the SDLC phases (Requirements, Design, Implementation, Testing, Deployment), highlighting the importance of each phase and how they interconnect.


Software Development Life Cycle (SDLC) Phases

1. Requirements

Objective:
	 Understand what the software should do and its functional and non-functional requirements.

Importance:

1.Sets the foundation for the entire project.

2.Aligns development with business goals.

3.Defines scope and user expectations.

2. Design

Objective:
	 Plan how the software will be structured and function based on the requirements.

Importance:

   1.Transforms requirements into detailed system specifications.

   2.Guides developers in coding and implementation.

   3.Includes architectural, UI/UX, and database design.

3. Implementation

Objective: 
	Write code and develop the software according to the design specifications.

Importance:

	1.Turns design into a working product.

	2.Involves coding, unit integration, and version control.

	3.Builds the core functionality of the software.

4. Testing

Objective:
	 Verify and validate the software to ensure it meets quality standards and works as expected.

Importance:

	1.Identifies and fixes defects early in the development cycle.

	2.Includes unit testing, integration testing, system testing, and user acceptance testing (UAT).

	3.Ensures software reliability, security, and usability.

5. Deployment

Objective:
	 Deploy the software into the production environment and make it available to users.

Importance:

	1.Transitions the software from development to live operations.
	2.Involves installation, configuration, and data migration.
	3.Includes user training and support for a smooth transition.

Interconnection of Phases:

Requirements to Design:
		 Designs are based on gathered requirements, ensuring alignment with user needs.

Design to Implementation:
		 Implementation follows design specifications, translating them into actual code.

Implementation to Testing:
		 Testing verifies that implemented code meets requirements and design expectations.

Testing to Deployment:
		 Deployment ensures that tested and validated software is released to users effectively.




Assessment 2:Develop a case study analyzing the implementation of SDLC phases in a real-world engineering project. Evaluate how Requirement Gathering, Design, Implementation, Testing, Deployment, and Maintenance contribute to project outcomes.


Case Study: Implementation of SDLC Phases in a Manufacturing Software Project
1. Requirement Gathering Phase:
Objective: To understand the current inventory management process and gather requirements for the new software system.


Activities:

Meetings with Stakeholders: 
	Engage with warehouse managers, inventory specialists, and IT staff to understand current pain points and desired features.

Document Requirements: 
	Create a detailed requirements document outlining functional and non-functional requirements, such as inventory tracking, reporting capabilities, integration with existing ERP systems, and user roles.


Outcome: 
	A comprehensive requirements specification document approved by stakeholders, serving as the basis for subsequent phases.

2. Design Phase:
Objective:
 To create a detailed blueprint of the software system based on gathered requirements.

Activities:

System Architecture Design: 
	Define the overall structure of the software, including modules, databases, and interfaces.

UI/UX Design: 
	Design user interfaces and user experience flows to ensure ease of use for warehouse staff.

Detailed Design:
	 Specify algorithms, data structures, and workflows needed to implement the functionality.

Outcome: 
	Design documents including architectural diagrams, UI prototypes, and detailed specifications ready for implementation.


3. Implementation Phase:
Objective: To translate the design into actual code and develop the software system.

Activities:

Coding:
	 Developers write code based on the design specifications using appropriate programming languages and frameworks.

Integration: 
	Integrate different modules and ensure they work together seamlessly.

Version Control:
	 Use version control systems (e.g., Git) to manage code changes and collaboration among team members.

Outcome:
	 Developed software system with all planned features implemented according to specifications.


4. Testing Phase:

Objective: 
	To identify and fix defects in the software to ensure it meets quality standards.

Activities:

Unit Testing: 
	Developers test individual modules to ensure they function correctly.

Integration Testing: 
	Verify that integrated modules work together as expected.
System Testing:
	 Test the entire system to validate against the requirements.

User Acceptance Testing (UAT):
	 Conduct tests with end-users to ensure the software meets their needs and expectations.

Outcome:
	 A tested and validated software system ready for deployment.

5. Deployment Phase:

Objective:
	 To deploy the software system into the production environment and make it accessible to users.

Activities:

Deployment Planning:
	 Create a deployment plan outlining steps, roles, and responsibilities.

Installation: 
	Install the software on servers and client machines as required.

Data Migration: 
	Transfer existing data from old systems to the new software.

Training: 
	Provide training sessions for end-users and administrators on how to use the new system effectively.

Outcome:
	 Successfully deployed software system available for use by warehouse staff.

6. Maintenance Phase:

Objective:
	 To support and maintain the software system post-deployment to ensure its continued functionality and performance.

Activities:

Monitoring and Support:
	 Monitor system performance, respond to user inquiries, and provide technical support as needed.

Bug Fixes and Updates:
	 Address reported bugs and implement software updates to improve functionality or address security vulnerabilities.

Enhancements:
	 Implement new features or enhancements based on user feedback and changing business needs.

Outcome:
	 Ongoing support and improvement of the software system to adapt to evolving requirements and technologies.


Evaluation of SDLC Phases Contribution to Project Outcomes:


Requirement Gathering: 
	Ensured alignment with stakeholders' needs, preventing miscommunication and ensuring the software met user expectations.

Design:
	 Provided a clear roadmap for development, minimizing risks and ensuring efficient use of resources.

Implementation:
	 Transformed design into a functional system, adhering to specifications and design principles.

Testing:
	 Identified and resolved defects early, ensuring high quality and reliability of the software.

Deployment:
	 Successfully rolled out the software without disruptions to operations, enabling immediate benefits from the new system.

Maintenance:
	 Supported ongoing operations and facilitated continuous improvement of the software, enhancing long-term usability and value.





Assessment 3:: Research and compare SDLC models suitable for engineering projects. Present findings on Waterfall, Agile, Spiral, and V-Model approaches, emphasizing their advantages, disadvantages, and applicability in different engineering contexts.


1.Waterfall model:
 
The classical waterfall model is the basic software development life cycle model.it is very simple but idealistic.it was very popular but nowadays is not used. it is very important because all other software development life cycles models are based on the classical waterfall model.

Advantages:
1.Simple and easy to understand: 
       The sequential nature makes it easy to manage and track progress.

2.Well suited for small projects with well-defined requirements:
      When requirements are clear and unlikely to change significantly.


Disadvantages:

1.Rigid and inflexible:
       Difficult to accommodate changes once development starts.

2.High Risk: 
     If requirements are not well understood initially, it can lead to costly changes later.

3.Limited customer interaction:
    Customers see the product only at the end , which can lead to surprises and misunderstandings.

Applications:

   Best suited for projects where requirements are well understood and unlikely to change, such as in construction or manufacturing projects.


Agile model:
   The Agile software development life cycle is an iterative and incremental software development methodology that prioritizes flexibility, collaboration and customer feedback.


Advantages :

1.Flexibility and adaptability:
     Emphasizes iterative development and continuous improvement.

2.Customer involvement:
    Regular feedback from customers ensures the product meets their needs

3.Reduced risk:
    Changes are expected and easily accommodated during short iterations.

Disadvantages :

1.Complexity in large projects:
     Requires experienced team members and strong project management.

2. Dependency on customer availability:
      Requires active customer participation throughout the project.

3.Documentation can be lacking:
     Agile values working software over comprehensive documentation , which can be a disadvantage in heavily regulated industries.

Applicability:
      Ideal for projects where requirements are likely to evolve , such as software development or innovative product development.

Spiral model:

     The Spiral Model is a Software Development Life Cycle model that provides a systematic and iterative approach to software development. In its diagrammatic representation, looks like a spiral with many loops. The exact number of loops of the spiral is unknown and can vary from project to project. Each loop of the spiral is called a phase of the software development process.

Advantages:
   

1.Risk management:
          Risk analysis and mitigation are inherent in each phase, reducing uncertainty.

2.Flexibility: 
	Changes can be incorporated as the product progresses through iterative cycles.

3.Good for large and complex projects: 
		Especially those where risk assessment is crucial, such as in aerospace or defense projects.


Disadvantages:

1.Complexity: 
	Requires considerable expertise to apply effectively.
      
2.Costly: 
	Can be more expensive due to the risk analysis and extensive documentation required.

3.Time-consuming: 
	Each cycle must be carefully planned and executed, which can lead to longer development times.


Applicability: 
	Suitable for large-scale projects where continuous risk assessment and management are critical, such as in high-risk engineering projects.


V-Model:

  	The V-model is a type of SDLC model where the process executes sequentially in a V-shape. It is also known as the Verification and Validation model. It is based on the association of a testing phase for each corresponding development stage


Advantages:

1.Emphasis on testing: 
	Testing activities are integrated into each phase, ensuring high-quality deliverables.

2.Clear and well-defined stages:
	 Each stage has specific deliverables and a corresponding testing phase

3.Works well with waterfall-like processes:
	 Especially in environments where requirements are stable and predictable.

Disadvantages:

1.Rigid: 
	Changes in requirements can cause cascading changes across stages, leading to delays.

2.Limited flexibility: 
	Difficult to accommodate significant changes once development has started.

3.Not suitable for all projects:
	 Less effective in projects where requirements are not well understood upfront.

Applicability: 
	Best suited for projects with clear and stable requirements where testing and verification are critical, such as in regulatory-driven industries like healthcare or automotive.


conclusion:

	1.Waterfall is best for projects with stable and well-understood requirements.
	2.Agile is ideal for projects where flexibility and continuous customer feedback are essential.
	3.Spiral suits projects with high uncertainty and a need for rigorous risk management.
	4.V-Model works well in projects where testing and verification are paramount, and requirements are relatively stable.

	Choosing the right SDLC model depends on the specific project requirements, risk tolerance, and the nature of the product being developed. Hybrid approaches combining elements from these models are also common to tailor processes more closely to project needs.
